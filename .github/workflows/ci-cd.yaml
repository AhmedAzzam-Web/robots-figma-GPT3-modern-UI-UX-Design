# Continuous Delivery pipeline: build & push image, apply Terraform, deploy to AKS on tag release
name: CD

on:
  push:
    tags:
      - "v*.*"

# Add permissions for OIDC authentication
permissions:
  id-token: write
  contents: read

env:
  PROJECT_NAME: robots-figma
  AZURE_LOCATION: eastus
  TF_WORKING_DIR: infra/terraform
  K8S_DIR: infra/k8s

jobs:
  infra:
    name: Provision Infra with Terraform
    runs-on: ubuntu-latest
    # Define job outputs to be used by other jobs
    outputs:
      acr_login_server: ${{ steps.tf_outputs.outputs.acr_login_server }}
      aks_cluster_name: ${{ steps.tf_outputs.outputs.aks_cluster_name }}
      resource_group_name: ${{ steps.tf_outputs.outputs.resource_group_name }}

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login using OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        run: terraform init -input=false
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Validate
        run: terraform validate
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Plan
        run: terraform plan -out=tfplan -input=false
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
        working-directory: ${{ env.TF_WORKING_DIR }}
        
      - name: Export Terraform outputs as job outputs
        id: tf_outputs
        run: |
          echo "acr_login_server=$(terraform output -raw acr_login_server)" >> $GITHUB_OUTPUT
          echo "aks_cluster_name=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT
          echo "resource_group_name=$(terraform output -raw aks_resource_group_name)" >> $GITHUB_OUTPUT
        working-directory: ${{ env.TF_WORKING_DIR }}

  build_push:
    name: Build and Push Image to ACR
    runs-on: ubuntu-latest
    needs: infra # Depends on the infra job
    outputs:
      image_tag: ${{ steps.build.outputs.image }} # Output the final image tag

    steps:
      - uses: actions/checkout@v4

      - name: Get version from git tag
        id: vars
        run: echo "version=${GITHUB_REF##*/}" >> $GITHUB_OUTPUT

      - name: Azure Login using OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # Use the standard Docker action for logging into a container registry
      - name: Docker Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ needs.infra.outputs.acr_login_server }}
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }} # Or use `az acr login` with managed identity

      - name: Build and Push Docker image
        id: build
        run: |
          IMAGE="${{ needs.infra.outputs.acr_login_server }}/${{ env.PROJECT_NAME }}:${{ steps.vars.outputs.version }}"
          docker build -t $IMAGE -f Dockerfile .
          docker push $IMAGE
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: [infra, build_push] # Depends on both previous jobs

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login using OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ needs.infra.outputs.resource_group_name }}
          cluster-name: ${{ needs.infra.outputs.aks_cluster_name }}
      
      - name: Setup Kustomize
        uses: imranismail/setup-kustomize@v2

      - name: Update Kubernetes manifests with new image tag
        run: |
          cd ${{ env.K8S_DIR }}
          kustomize edit set image aplication-image=${{ needs.build_push.outputs.image_tag }}
      
      - name: Deploy to Kubernetes
        run: kubectl apply -k ${{ env.K8S_DIR }}